// Generated by CoffeeScript 1.7.1
(function() {
  var Q, User, crypto;

  Q = require('q');

  crypto = require('crypto');

  User = (function() {
    var HASH_ALGORITHM, HASH_ITERATIONS, HASH_KEY_LEN, HASH_SALT_LEN, hashPassword, verifyPassword;

    function User() {}

    HASH_ALGORITHM = 'pbkdf2';

    HASH_ITERATIONS = 100;

    HASH_KEY_LEN = 128;

    HASH_SALT_LEN = 64;

    User.checkUsernameAvailable = function(username, dbClient) {
      var defer;
      defer = Q.defer();
      dbClient.query('SELECT COUNT(*) > 0 AS user_exists FROM users' + ' WHERE username = $1', [username], function(err, result) {
        if (err) {
          defer.reject(err);
        }
        if (result.rows[0].user_exists) {
          return defer.reject(new Error('User already exists with that name'));
        } else {
          return defer.resolve();
        }
      });
      return defer.promise;
    };

    hashPassword = function(password) {
      var salt;
      salt = crypto.randomBytes(HASH_SALT_LEN).toString('base64');
      return Q.nfapply(crypto[HASH_ALGORITHM], [password, salt, HASH_ITERATIONS, HASH_KEY_LEN]).then(function(derivedKey) {
        return HASH_ALGORITHM + ":" + HASH_ITERATIONS + ":" + HASH_KEY_LEN + ":" + salt + ":" + derivedKey.toString('base64');
      });
    };

    verifyPassword = function(hash, password) {
      var algorithm, iterations, key, keyLen, salt, _ref;
      _ref = hash.split(':'), algorithm = _ref[0], iterations = _ref[1], keyLen = _ref[2], salt = _ref[3], key = _ref[4];
      iterations = parseInt(iterations, 10);
      keyLen = parseInt(keyLen, 10);
      if (typeof crypto[algorithm] !== "function") {
        return Q.reject('Invalid algorithm');
      }
      if (typeof iterations !== "number" || iterations < 0) {
        return Q.reject('Invalid iterations');
      }
      if (typeof keyLen !== "number" || keyLen < 0) {
        return Q.reject('Invalid keyLen');
      }
      if (typeof key !== "string") {
        return Q.reject('Invalid key');
      }
      if (typeof salt !== "string") {
        return Q.reject('Invalid key');
      }
      return Q.nfapply(crypto[algorithm], [password, salt, iterations, keyLen]).then(function(derivedKey) {
        return derivedKey.toString('base64') === key;
      });
    };

    User.register = function(username, password, dbClient) {
      return this.checkUsernameAvailable(username, dbClient).then(function() {
        return hashPassword(password);
      }).then(function(hash) {
        return true;
      });
    };

    return User;

  })();

  module.exports = User;

}).call(this);
